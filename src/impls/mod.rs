pub mod auth;
pub mod chat;
pub mod emote;
pub mod mediaproxy;
pub mod profile;
pub mod rest;
pub mod sync;

use std::{
    str::FromStr,
    time::{Duration, UNIX_EPOCH},
};

use dashmap::DashMap;
use harmony_rust_sdk::api::exports::{
    hrpc::{
        http,
        server::filters::{rate::Rate, rate_limit},
        warp::{self, filters::BoxedFilter, Filter, Reply},
    },
    prost::bytes::Bytes,
};
use parking_lot::Mutex;
use rand::Rng;
use reqwest::{Response, Url};
use smol_str::SmolStr;
use tokio::sync::{broadcast, mpsc};
use triomphe::Arc;

use crate::{
    config::Config,
    db::{ArcTree, Db, DbResult},
    impls::rest::reject,
    key, ServerError, SharedConfig, SharedConfigData, SCHERZO_VERSION,
};

use self::{
    auth::SessionMap, chat::ChatTree, emote::EmoteTree, profile::ProfileTree, sync::EventDispatch,
};

pub type FedEventReceiver = mpsc::UnboundedReceiver<EventDispatch>;
pub type FedEventDispatcher = mpsc::UnboundedSender<EventDispatch>;

pub struct Dependencies {
    pub auth_tree: ArcTree,
    pub chat_tree: ChatTree,
    pub profile_tree: ProfileTree,
    pub emote_tree: EmoteTree,
    pub sync_tree: ArcTree,

    pub valid_sessions: SessionMap,
    pub chat_event_sender: chat::EventSender,
    pub fed_event_dispatcher: FedEventDispatcher,
    pub key_manager: Option<Arc<key::Manager>>,

    pub config: Config,
    pub runtime_config: SharedConfig,
}

impl Dependencies {
    pub fn new(db: &dyn Db, config: Config) -> DbResult<(Self, FedEventReceiver)> {
        let (fed_event_dispatcher, fed_event_receiver) = mpsc::unbounded_channel();

        let this = Self {
            auth_tree: db.open_tree(b"auth")?,
            chat_tree: ChatTree::new(db)?,
            profile_tree: ProfileTree::new(db)?,
            emote_tree: EmoteTree::new(db)?,
            sync_tree: db.open_tree(b"sync")?,

            valid_sessions: Arc::new(DashMap::default()),
            chat_event_sender: broadcast::channel(1000).0,
            fed_event_dispatcher,
            key_manager: config
                .federation
                .as_ref()
                .map(|fc| Arc::new(key::Manager::new(fc.key.clone()))),

            config,
            runtime_config: Arc::new(Mutex::new(SharedConfigData::default())),
        };

        Ok((this, fed_event_receiver))
    }
}

fn get_time_secs() -> u64 {
    UNIX_EPOCH
        .elapsed()
        .expect("time is before unix epoch")
        .as_secs()
}

fn gen_rand_inline_str() -> SmolStr {
    // Safety: arrays generated by gen_rand_arr are alphanumeric, so they are valid ASCII chars as well as UTF-8 chars [ref:alphanumeric_array_gen]
    let arr = gen_rand_arr::<_, 22>(&mut rand::thread_rng());
    let str = unsafe { std::str::from_utf8_unchecked(&arr) };
    // Safety: generated array is exactly 22 u8s long
    SmolStr::new_inline(str)
}

#[allow(dead_code)]
fn gen_rand_str<const LEN: usize>() -> SmolStr {
    let arr = gen_rand_arr::<_, LEN>(&mut rand::thread_rng());
    // Safety: arrays generated by gen_rand_arr are alphanumeric, so they are valid ASCII chars as well as UTF-8 chars [ref:alphanumeric_array_gen]
    let str = unsafe { std::str::from_utf8_unchecked(&arr) };
    SmolStr::new(str)
}

fn gen_rand_arr<RNG: Rng, const LEN: usize>(rng: &mut RNG) -> [u8; LEN] {
    let mut res = [0_u8; LEN];

    let random = rng
        .sample_iter(rand::distributions::Alphanumeric) // [tag:alphanumeric_array_gen]
        .take(LEN);

    random
        .zip(res.iter_mut())
        .for_each(|(new_ch, ch)| *ch = new_ch);

    res
}

fn gen_rand_u64() -> u64 {
    rand::thread_rng().gen_range(1..u64::MAX)
}

fn rate(num: u64, dur: u64) -> BoxedFilter<()> {
    rate_limit(
        Rate::new(num, Duration::from_secs(dur)),
        ServerError::TooFast,
    )
    .boxed()
}

fn get_mimetype(response: &Response) -> &str {
    response
        .headers()
        .get(&http::header::CONTENT_TYPE)
        .and_then(|val| val.to_str().ok())
        .and_then(|s| s.split(';').next())
        .unwrap_or("application/octet-stream")
}

fn get_content_length(response: &Response) -> http::HeaderValue {
    response
        .headers()
        .get(&http::header::CONTENT_LENGTH)
        .cloned()
        .unwrap_or_else(|| unsafe {
            http::HeaderValue::from_maybe_shared_unchecked(Bytes::from_static(b"0"))
        })
}

pub fn about(deps: &Dependencies) -> BoxedFilter<(impl Reply,)> {
    use harmony_rust_sdk::api::rest::About;

    let about_server = deps.config.server_description.clone();
    let shared_config = deps.runtime_config.clone();

    warp::get()
        .and(warp::path!("_harmony" / "about"))
        .map(move || {
            warp::reply::json(&About {
                server_name: "Scherzo".to_string(),
                version: SCHERZO_VERSION.to_string(),
                about_server: about_server.clone(),
                message_of_the_day: shared_config.lock().motd.clone(),
            })
        })
        .boxed()
}

pub fn against_proxy() -> BoxedFilter<(impl Reply,)> {
    let http = reqwest::Client::new();

    // TODO: return a proper server error instead of just using header
    // which discards the FromStr error
    warp::header::<HomeserverIdentifier>("Against")
        .and(warp::path::full())
        .and(warp::body::body())
        .and(warp::header::headers_cloned())
        .and_then(
            move |host_id: HomeserverIdentifier, path: warp::path::FullPath, body, headers| {
                let http = http.clone();
                async move {
                    use reqwest::{Method, Request};

                    // TODO: don't use unwrap, handle error
                    let url = host_id.to_url().unwrap().join(path.as_str()).unwrap();
                    let mut request = Request::new(Method::POST, url);
                    *request.body_mut() = Some(reqwest::Body::wrap_stream(body));
                    // TODO: only pass harmony headers
                    *request.headers_mut() = headers;

                    let response = http.execute(request).await.map_err(reject)?;
                    let stream = response.bytes_stream();

                    let mut response =
                        warp::reply::Response::new(warp::hyper::Body::wrap_stream(stream));
                    *response.headers_mut() = response.headers().clone();
                    *response.status_mut() = response.status();

                    Result::<_, warp::Rejection>::Ok(response)
                }
            },
        )
        .boxed()
}

use harmony_rust_sdk::api::exports::hrpc::url::ParseError;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HomeserverIdentifier {
    domain: SmolStr,
    port: u16,
}

impl HomeserverIdentifier {
    pub fn to_url(&self) -> Result<Url, ParseError> {
        let mut url = Url::parse("https://example.net").unwrap();
        url.set_host(Some(self.domain.as_str()))?;
        url.set_port(Some(self.port))
            .map_err(|_| ParseError::InvalidPort)?;
        Ok(url)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HomeserverIdParseError {
    /// Port wasn't a `u16`.
    InvalidPort,
    /// Port was missing.
    MissingPort,
    /// Domain was missing.
    MissingDomain,
}

impl FromStr for HomeserverIdentifier {
    type Err = HomeserverIdParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut split = s.split(':');

        let domain = split.next().ok_or(HomeserverIdParseError::MissingDomain)?;
        let port_raw = split.next().ok_or(HomeserverIdParseError::MissingPort)?;

        let port: u16 = port_raw
            .parse()
            .map_err(|_| HomeserverIdParseError::InvalidPort)?;

        Ok(Self {
            domain: SmolStr::new(domain),
            port,
        })
    }
}
